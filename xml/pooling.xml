<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.3">
  <compounddef id="pooling" kind="page">
    <compoundname>pooling</compoundname>
    <title>Pooling</title>
    <detaileddescription>
<para>Object pooling for performance.</para><para>Pooling is a great way to maximize the performance for heavy usage of the system or when running on low end hardware (e.g mobile). The Mono Garbage Collector does quite a good job collecting the objects which are not used anymore, but one major problem is that every time the GC is run, it needs to freeze the game while it runs. You might have noticed this as small hickups in your game every few seconds. Especially on mobile with limited ram and processor power this is a problem.</para><para>One solution to this is to pool most objects. That is, when an object is not used anymore you put it in a pool and some time after that, when you need a new instance of the same type of object, you ask the pool if there are any objects in it which can be got easily. Using pools will decrease the load on the GC and thus reducing the number of hickups in the game.</para><sect1 id="pooling_1path-pooling">
<title>Path Pooling</title>
<para>Pooling is mostly used with Paths and lists in the A* <ref refid="namespace_pathfinding" kindref="compound">Pathfinding</ref> Project since that is what is allocated the most. Adding pooling logic to your scripts requires very little code, but it can be error prone if not done correctly.</para><para>The pooling in the A* <ref refid="namespace_pathfinding" kindref="compound">Pathfinding</ref> Project is based on a kind of manual reference counting. When you start using a path object you should call the special function .Claim on it, and when you stop using it, e.g because it is replaced by a newer path, you should release it with the special Release function. When the release function has been called on a path and no other scripts are using it, it may be recycled at any time. This means that its variables can get reset at any time as well, so after you have called release on a path, you should never keep the reference to it (or at least make sure not to use it again).</para><para><simplesect kind="see"><para><ref refid="class_pathfinding_1_1_path_1a1f9e835985c570abc78be7a62c675655" kindref="member">Pathfinding.Path.Claim</ref> </para><simplesectsep/><para><ref refid="class_pathfinding_1_1_path_1a1ec02830fecdbafb6bfc14cd0a6fee88" kindref="member">Pathfinding.Path.Release</ref></para></simplesect>
If you do not call claim or release on a path, it will simply not be pooled. So if you don&apos;t want to bother about pooling, you don&apos;t have to. If you only call Claim on a path, but forget to call Release and then all your references to it are removed, it will still be garbage collected but it will not be put back in the pool. If you call Release on a path without having called Claim on it before, or simply call Release multiple times, it will log an error.</para><para>Just to give you an example, here is a typical path pooling usage: <programlisting><codeline><highlight class="keyword">public</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">AI<sp/>:<sp/>MonoBehaviour<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ABPath<sp/>path;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>IEnumerator<sp/>Start<sp/>()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">true</highlight><highlight class="normal">)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>GetComponent&lt;Seeker&gt;().StartPath<sp/>(transform.position,<sp/>transform.position<sp/>+<sp/>transform.forward*10,<sp/>OnPathComplete);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>OnPathComplete<sp/>(Path<sp/>p)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Release<sp/>any<sp/>previous<sp/>paths</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(path<sp/>!=<sp/>null)<sp/>path.Release<sp/>(</highlight><highlight class="keyword">this</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>path<sp/>=<sp/>p<sp/>as<sp/>ABPath;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Claim<sp/>the<sp/>new<sp/>path</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>path.Claim<sp/>(</highlight><highlight class="keyword">this</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Update<sp/>()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Draw<sp/>the<sp/>path<sp/>in<sp/>the<sp/>editor</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(path<sp/>!=<sp/>null<sp/>&amp;&amp;<sp/>path.vectorPath<sp/>!=<sp/>null)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;i&lt;path.vectorPath.Count-1;i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Debug.DrawLine<sp/>(path.vectorPath[i],path.vectorPath[i+1],Color.green);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Note also that when a path is recycled, i.e put back in the pool after it has been released, the vectorPath and path variables on it (and any other lists if the path type had more) will also be recycled. So it is not safe to grab the vectorPath from a path object and then recycle the path object but continue using the vectorPath.</para><para>The Claim and Release functions take an object reference, it is there mainly to reduce the possibility of user error. Error checking is done so that a path is not released multiple times using the same object, or claimed multiple times.</para></sect1>
<sect1 id="pooling_1list-pooling">
<title>List Pooling</title>
<para>Maybe not as important for most users, but it might be relevant for advanced users. The project does also include list pooling of generic lists. This is used internally by the system to avoid allocating new lists every time. The list pooling classes are really simple to use, simply get a reference using Pathfinding.Util.ListPool.Claim and when you are done with it release it using Pathfinding.Util.ListPool.Release. The ListPool class takes a type argument, so you can use it with any list type. <programlisting><codeline><highlight class="comment">//Get<sp/>a<sp/>reference<sp/>to<sp/>a<sp/>list</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">List&lt;int&gt;<sp/>myList<sp/>=<sp/>Pathfinding.Util.ListPool&lt;</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">&gt;.Claim<sp/>();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//Do<sp/>something<sp/>with<sp/>it</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;i&lt;100;i++)<sp/>myList.Add<sp/>(i);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>fiftytwo<sp/>=<sp/>myList[52];</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//Release<sp/>it</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Pathfinding.Util.ListPool&lt;</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">&gt;.Release<sp/>(myList);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//Set<sp/>reference<sp/>to<sp/>null<sp/>to<sp/>make<sp/>sure<sp/>we<sp/>don&apos;t<sp/>use<sp/>it<sp/>again<sp/>by<sp/>mistake</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">myList<sp/>=<sp/>null;</highlight></codeline>
</programlisting></para></sect1>
<sect1 id="pooling_1debug">
<title>Debugging</title>
<para>Since pooling might be a bit hard to set up, depending on how complex the scripts are that you use it with, and the results are not instantly verifiable, it can be great to have a debugger. There is one included in the A* <ref refid="namespace_pathfinding" kindref="compound">Pathfinding</ref> Project. Add the script Components -&gt; <ref refid="namespace_pathfinding" kindref="compound">Pathfinding</ref> -&gt; Debugger to any GameObject. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
