<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.3">
  <compounddef id="getstarted" kind="page">
    <compoundname>getstarted</compoundname>
    <title>Get Started With The A* Pathfinding Project</title>
    <detaileddescription>
<para><ref refid="namespace_pathfinding" kindref="compound">Pathfinding</ref> is all about finding the best path between point A and B.</para><para>This is what the A* <ref refid="namespace_pathfinding" kindref="compound">Pathfinding</ref> Project does, in this tutorial you will learn how to set up the project in a new scene and get a simple AI moving while avoiding obstacles.</para><sect1 id="getstarted_1downloading">
<title>Downloading</title>
<para>The first thing you need to do, if you haven&apos;t done so already, is to download the A* Pathfinding Project<linebreak/>
 The project can be downloaded from <ulink url="http://www.arongranberg.com/unity/a-pathfinding/download">here</ulink>, you can either download the free version with some limited features (but still very powerful) or buy the pro version with more cool stuff included.<linebreak/>
 If you want, you can explore the different example scenes in the project before you start with the next section.</para></sect1>
<sect1 id="getstarted_1js">
<title>Javascript (Unityscript)</title>
<para>If you are using UnityScript, you should first follow the instructions on the page <ref refid="javscript" kindref="compound">Working with Javascript</ref>.</para><para>All example code is in C#. But I hope it will not be too hard following them since C# and Unityscript are quite similar. You should know that unityscript does not support optional parameters. So you must always pass all parameters to a function. If you get an error message that the function you are trying to call has no such overload, this might be the problem. Then check the docs for all parameters and their default values.</para></sect1>
<sect1 id="getstarted_1usingIphone">
<title>Deploying for iPhone</title>
<para>Depending on which platform you are building for, you might want to read this page first: <ref refid="iphone" kindref="compound">Deploying for iphone</ref></para></sect1>
<sect1 id="index_1errors">
<title>Errors?</title>
<para>At this stage, if you are getting any compiler errors from the code you can first check the Readme_upgrading.txt file included, if you are upgrading from an older version. A common problem is that classes in the A* <ref refid="namespace_pathfinding" kindref="compound">Pathfinding</ref> Project have the same name as classes in your project. This can be solved either by renaming one of the classes, or placing your class in a namespace so it will not conflict with the other class anymore.</para><para>If you are still getting errors, take a look at the forums (see <ulink url="http://www.arongranberg.com/vanillaforums/">http://www.arongranberg.com/vanillaforums/</ulink>) to see if anyone else has the same problem or post a new question there.</para></sect1>
<sect1 id="local-avoidance_1overview">
<title>Overview</title>
<para><itemizedlist>
<listitem><para>The central script of the A* <ref refid="namespace_pathfinding" kindref="compound">Pathfinding</ref> Project is the script &apos;astarpath.cs&apos;, it acts as a central hub for everything else.<linebreak/>
 In the <ref refid="class_astar_path" kindref="compound">AstarPath</ref> inspector you create all graphs and adjust all settings.<linebreak/>
 There should always be one (always one, no more) astarpath.cs component in a scene which uses pathfinding.<linebreak/>
 The astarpath.cs script can be found at Components<ndash/>&gt;<ref refid="namespace_pathfinding" kindref="compound">Pathfinding</ref><ndash/>&gt;Pathfinder</para></listitem><listitem><para>The second most important component is the &apos;Seeker.cs&apos; component, a <ref refid="class_seeker" kindref="compound">Seeker</ref> component should be attached to every GameObject which uses pathfinding (e.g all AIs).<linebreak/>
 The <ref refid="class_seeker" kindref="compound">Seeker</ref> component handles path calls for one unit and post processes the paths. The <ref refid="class_seeker" kindref="compound">Seeker</ref> isn&apos;t needed, but it makes pathfinding easier.</para></listitem><listitem><para>Lastly there are the modifier scripts (e.g SimpleSmoothModifier.cs). Modifiers post-processes paths to smooth or simplify them, if a modifier is attached to the same GameObject as a <ref refid="class_seeker" kindref="compound">Seeker</ref> it will post-process all paths that <ref refid="class_seeker" kindref="compound">Seeker</ref> handles. See <ref refid="modifiers" kindref="compound">Using Modifiers</ref>.</para></listitem></itemizedlist>
</para></sect1>
<sect1 id="getstarted_1newscene">
<title>New Scene</title>
<para>Create a new scene, name it &quot;PathfindingTest&quot;. Now let&apos;s create something which an AI could walk on and something for it to avoid: add a plane to the scene, place it in the scene origin (0,0,0) and scale it to 10,10,10.<linebreak/>
 Create a new layer (Edit-&gt;Project Settings-&gt;Tags) named &quot;Ground&quot; and place the plane in that layer. Now create some cubes of differerent scales and place them on the plane, these will be obstacles which the AI should avoid. Place them in a new layer named &quot;Obstacles&quot;.<linebreak/>
 Your scene should now look something like this: <htmlonly> &lt;div class=&quot;tinyshadow&quot;&gt;&lt;img src=&quot;images/getstarted/getStarted_step1.png&quot;/&gt;&lt;/div&gt;</htmlonly></para></sect1>
<sect1 id="getstarted_1addingastar">
<title>Adding A*</title>
<para>Now we have ground for an AI to stand on and obstacles for it to avoid. So now we are going to add the A* <ref refid="namespace_pathfinding" kindref="compound">Pathfinding</ref> System to the scene to enable pathfinding.<linebreak/>
 Create a new GameObject, name it &quot;A*&quot;, add the &quot;AstarPath&quot; component to it (Components<ndash/>&gt;<ref refid="namespace_pathfinding" kindref="compound">Pathfinding</ref><ndash/>&gt;Pathfinder).<linebreak/>
 The <ref refid="class_astar_path" kindref="compound">AstarPath</ref> inspector is divided into several parts. The two most important is the Graphs area and the Scan button at the bottom.<linebreak/>
 The Graphs area holds all the graphs in your scene, you may have up to 16 but usually 1 or 2 will be sufficient. A single graph is usually to be preferred.<linebreak/>
 If you open the Graphs area by clicking on it you will see a list of graphs which you can add. I can&apos;t explain them all here but the two main ones is the Grid Graph which generates nodes in a grid pattern and the Navmesh Graph which takes a mesh as the walkable area.<linebreak/>
 The Scan button is for updating the graphs, this is also done on startup (unless the startup is cached, more about that in another part) and some graphs will do it automatically when changing the graph settings and the scanning won&apos;t cause any lag.<linebreak/>
 There is also a <ref refid="shortcuts" kindref="compound">shortcut</ref> to use Cmd+Alt+S (mac) or Ctrl+Alt+S (windows).</para><para>For this tutorial we will create a Grid Graph, after adding it, click on the new <ref refid="class_pathfinding_1_1_grid_graph" kindref="compound">Grid Graph </ref> label to bring up the graph inspector. <htmlonly> &lt;div class=&quot;tinyshadow&quot;&gt;&lt;img src=&quot;images/getstarted/gridgraph_inspector.png&quot;/&gt;&lt;/div&gt;</htmlonly> As the name implies, the GridGraph will generate a grid of nodes, width*depth. A grid can be positioned anywhere in the scene and you can rotate it any way you want.<linebreak/>
 The Node Size variable determines how large a square/node in the grid is, for this tutorial you can leave it at 1, so the nodes will be spaced 1 unit apart.<linebreak/>
 The position needs to be changed though. Switch to bottom-left in the small selector to the right of the position field (currently named &quot;Center&quot;), then enter (-50,-0.1,-50). The -0.1 is to avoid floating point errors, in our scene the ground is at Y=0, if the graph was to have position Y=0 too, we might get annoying floating point errors when casting rays against it for example (like the height check does).<linebreak/>
 To make the grid fit our scene we need to change the width and depth variables, set both to 100 in this case. You can see that the grid is correctly positioned by the white bounding rectangle in the scene view which should now be enclosing the plane exactly.</para><sect2 id="getstarted_1heighttest">
<title>Height Testing</title>
<para>In order to place the nodes at their correct height, the A* system fires off a bunch of rays against the scene to see where they hit. That&apos;s the Height Testing settings.<linebreak/>
 A ray, optionally thick (as opposed to a line), is fired from [Ray Length] units above the grid downwards, a node is placed where it hits. If it doesn&apos;t hit anything, it is either made unwalkable if the Unwalkable When No Ground variable is toggled or the node is placed at Y=0 relative to the grid if it is set to false.<linebreak/>
 We need to change the mask used, currently it includes everything, but that would include our obstacles as well, and we don&apos;t want that. So set the Mask to only include the &quot;Ground&quot; layer which we created earlier.<linebreak/>
</para></sect2>
<sect2 id="getstarted_1collisiontest">
<title>Collision Testing</title>
<para>When a node has been placed, it is checked for walkability, this can be done with a Sphere, Capsule or a Ray. Usually a capsule is used with the same diameter and height as the AI character which is going to be walking around in the world, preferably with some margin though.<linebreak/>
 Our AI will have the standard diameter and height of 1 and 2 world units respectively, but we will set the diameter and height for the collision testing to 2 and 2 to get some margin.<linebreak/>
 Next, to make the system aware of the obstacles we placed, we need to change the mask for the Collision Testing, this time set it to contain only the &quot;Obstacles&quot; layer as we wouldn&apos;t want our ground to be treated as an obstacle.</para><para>Now everything should be set up correctly to scan the graph.<linebreak/>
 Press Scan. Wait a fraction of a second and you&apos;ve got a generated grid! (if you have done everything correctly, that is, compare your settings to the image below, also check that Show Graphs is true)<linebreak/>
 <table rows="1" cols="2"><row>
<entry thead="no"><para><htmlonly> &lt;div class=&quot;tinyshadow&quot;&gt;&lt;img src=&quot;images/getstarted/getStarted_step2_1.png&quot;/&gt;&lt;/div&gt;</htmlonly>  </para></entry><entry thead="no"><para><htmlonly> &lt;div class=&quot;tinyshadow&quot;&gt;&lt;img src=&quot;images/getstarted/getStarted_step2_2.png&quot;/&gt;&lt;/div&gt;</htmlonly>  </para></entry></row>
</table>
</para></sect2>
</sect1>
<sect1 id="getstarted_1addingai">
<title>Adding the AI</title>
<para>What is a pathfinding test without some moving stuff? Not fun at all, so let&apos;s add an AI to play around with.<linebreak/>
 Create a Capsule and add the Character Controller component to it, also place it somewhere visible on the plane.<linebreak/>
 Add the <ref refid="class_seeker" kindref="compound">Seeker</ref> component to the AI, this script is a helper script for calling pathfinding from other scripts, it can also handle path modifiers which can e.g smooth the path or simplify it using raycasts.<linebreak/>
 We are going to write our own, really simple script for moving the AI, so open your favourite script-editor and follow.</para></sect1>
<sect1 id="getstarted_1script">
<title>Moving Stuff Around</title>
<para>The call to the <ref refid="class_seeker" kindref="compound">Seeker</ref> is really simple, three arguments, a start position, an end position and a callback function (must be in the form &quot;void SomeFunction (Path p)&quot;): <programlisting><codeline><highlight class="keyword">function</highlight><highlight class="normal"><sp/>StartPath<sp/>(Vector3<sp/>start,<sp/>Vector3<sp/>end,<sp/>OnPathDelegate<sp/>callback<sp/>=<sp/>null)<sp/>:<sp/>Path<sp/></highlight></codeline>
</programlisting></para><para>So let&apos;s start our script with a simple snippet calling the pathfinder at startup: <programlisting><codeline><highlight class="keyword">using</highlight><highlight class="normal"><sp/>UnityEngine;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>System.Collections;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//Note<sp/>this<sp/>line,<sp/>if<sp/>it<sp/>is<sp/>left<sp/>out,<sp/>the<sp/>script<sp/>won&apos;t<sp/>know<sp/>that<sp/>the<sp/>class<sp/>&apos;Path&apos;<sp/>exists<sp/>and<sp/>it<sp/>will<sp/>throw<sp/>compiler<sp/>errors</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//This<sp/>line<sp/>should<sp/>always<sp/>be<sp/>present<sp/>at<sp/>the<sp/>top<sp/>of<sp/>scripts<sp/>which<sp/>use<sp/>pathfinding</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>Pathfinding;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">AstarAI<sp/>:<sp/>MonoBehaviour<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Vector3<sp/>targetPosition;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Start<sp/>()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Get<sp/>a<sp/>reference<sp/>to<sp/>the<sp/>Seeker<sp/>component<sp/>we<sp/>added<sp/>earlier</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="class_seeker" kindref="compound" tooltip="Handles path calls for a single unit.">Seeker</ref><sp/>seeker<sp/>=<sp/>GetComponent&lt;Seeker&gt;();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Start<sp/>a<sp/>new<sp/>path<sp/>to<sp/>the<sp/>targetPosition,<sp/>return<sp/>the<sp/>result<sp/>to<sp/>the<sp/>OnPathComplete<sp/>function</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>seeker.<ref refid="class_seeker_1ad9c281f768379478a6a3671a53e09113" kindref="member" tooltip="Call this function to start calculating a path.">StartPath</ref><sp/>(transform.position,targetPosition,<sp/>OnPathComplete);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>OnPathComplete<sp/>(Path<sp/>p)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Debug.Log<sp/>(</highlight><highlight class="stringliteral">&quot;Yey,<sp/>we<sp/>got<sp/>a<sp/>path<sp/>back.<sp/>Did<sp/>it<sp/>have<sp/>an<sp/>error?<sp/>&quot;</highlight><highlight class="normal">+p.error);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight></codeline>
</programlisting></para><para>Save it to a file in your project named AstarAI.cs and add the script to the AI GameObject.<linebreak/>
 In the inspector, change Target Position to something like (-20,0,22). This is the position the AI will try to find a path to now.<linebreak/>
 Press Play. You should get the log message and also the path should show in the scene view as a green line (the <ref refid="class_seeker" kindref="compound">Seeker</ref> component draws the latest path using Gizmos).<linebreak/>
 If you do not see a green line, make sure that the checkbox Show Gizmos on the <ref refid="class_seeker" kindref="compound">Seeker</ref> component is checked. More recent Unity versions also depth-test gizmos, so it might be hidden under the ground, to disable the depth-testing click the Gizmos button above the scene view window and uncheck the 3D Gizmos checkbox.<linebreak/>
 In case you get an error, make sure that the <ref refid="class_seeker" kindref="compound">Seeker</ref> component really is attached to the same GameObject as the AstarAI script. If you still get an error, the target position might not be reachable, try to change it a bit. <htmlonly> &lt;div class=&quot;tinyshadow&quot;&gt;&lt;img src=&quot;images/getstarted/getStarted_step3.png&quot;/&gt;&lt;/div&gt;</htmlonly> It looks a bit edgy, but that will do for now as you might be waiting for an explanation of what that code really did.</para><para>What happens is that first the script calls the <ref refid="class_seeker" kindref="compound">Seeker</ref>&apos;s StartPath function. The seeker will then create a new Path instance and then sent it forward to the <ref refid="class_astar_path" kindref="compound">AstarPath</ref> script (the Pathfinder component you added before). The <ref refid="class_astar_path" kindref="compound">AstarPath</ref> script will put the path in a queue. When available, the script will then process the path by searching the grid, node by node until the end node is found.<linebreak/>
 The searching step is explained really well in this tutorial <ulink url="http://www.policyalmanac.org/games/aStarTutorial.htm">here</ulink>. It does not work exactly like in the tutorial, but the concept is the same.<linebreak/>
 Once calculated the path is returned to the <ref refid="class_seeker" kindref="compound">Seeker</ref> which will post process it if any modifiers are attached and then the <ref refid="class_seeker" kindref="compound">Seeker</ref> will call the callback function specified in the call. The callback is also sent to <ref refid="class_seeker_1a383261cc8819e862d886b3e2da32d858" kindref="member">Seeker.pathCallback</ref> which you can register to if you don&apos;t want to specify a callback every time you call StartPath: <programlisting><codeline><highlight class="normal"><sp/></highlight><highlight class="comment">//OnPathComplete<sp/>will<sp/>be<sp/>called<sp/>every<sp/>time<sp/>a<sp/>path<sp/>is<sp/>returned<sp/>to<sp/>this<sp/>seeker</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">seeker.<ref refid="class_seeker_1a383261cc8819e862d886b3e2da32d858" kindref="member" tooltip="Callback for when a path is completed.">pathCallback</ref><sp/>+=<sp/>OnPathComplete;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//So<sp/>now<sp/>we<sp/>can<sp/>omit<sp/>the<sp/>callback<sp/>parameter</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">seeker.<ref refid="class_seeker_1ad9c281f768379478a6a3671a53e09113" kindref="member" tooltip="Call this function to start calculating a path.">StartPath</ref><sp/>(transform.position,targetPosition);<sp/></highlight></codeline>
</programlisting></para><para><simplesect kind="note"><para>When removing or destroying the script, callback references are not removed, so it is good practise to add a removing snipped in case that should happen<linebreak/>
 <programlisting><codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>OnDisable<sp/>()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>seeker.<ref refid="class_seeker_1a383261cc8819e862d886b3e2da32d858" kindref="member" tooltip="Callback for when a path is completed.">pathCallback</ref><sp/>-=<sp/>OnPathComplete;</highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight></codeline>
</programlisting></para></simplesect>
When we get the calculatated path back, how can we get info from it?<linebreak/>
 A Path instance contains two arrays related to that.<linebreak/>
 Path.vectorPath is a Vector3 array which holds the path, this array will be modified if any smoothing is used, it is the recommended way to get a path.<linebreak/>
 secondly there is the Path.path array which is an array of Node elements, it holds all the nodes the path visisted which can be useful to get additonal info on the traversed path.<linebreak/>
 First though, you should always check path.error, if that is true, the path has failed for some reason. Path.errorLog will have more info on what went wrong in case path.error is true.<linebreak/>
 <linebreak/>
 To expand our AI script, let&apos;s add some movement: Also add the CharacterController to the AI gameObject.</para><para><programlisting><codeline><highlight class="keyword">using</highlight><highlight class="normal"><sp/>UnityEngine;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>System.Collections;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//Note<sp/>this<sp/>line,<sp/>if<sp/>it<sp/>is<sp/>left<sp/>out,<sp/>the<sp/>script<sp/>won&apos;t<sp/>know<sp/>that<sp/>the<sp/>class<sp/>&apos;Path&apos;<sp/>exists<sp/>and<sp/>it<sp/>will<sp/>throw<sp/>compiler<sp/>errors</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//This<sp/>line<sp/>should<sp/>always<sp/>be<sp/>present<sp/>at<sp/>the<sp/>top<sp/>of<sp/>scripts<sp/>which<sp/>use<sp/>pathfinding</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>Pathfinding;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">AstarAI<sp/>:<sp/>MonoBehaviour<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//The<sp/>point<sp/>to<sp/>move<sp/>to</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Vector3<sp/>targetPosition;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">private</highlight><highlight class="normal"><sp/><ref refid="class_seeker" kindref="compound" tooltip="Handles path calls for a single unit.">Seeker</ref><sp/>seeker;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">private</highlight><highlight class="normal"><sp/>CharacterController<sp/>controller;</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//The<sp/>calculated<sp/>path</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>Path<sp/>path;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//The<sp/>AI&apos;s<sp/>speed<sp/>per<sp/>second</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>speed<sp/>=<sp/>100;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//The<sp/>max<sp/>distance<sp/>from<sp/>the<sp/>AI<sp/>to<sp/>a<sp/>waypoint<sp/>for<sp/>it<sp/>to<sp/>continue<sp/>to<sp/>the<sp/>next<sp/>waypoint</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>nextWaypointDistance<sp/>=<sp/>3;</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//The<sp/>waypoint<sp/>we<sp/>are<sp/>currently<sp/>moving<sp/>towards</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">private</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>currentWaypoint<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Start<sp/>()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>seeker<sp/>=<sp/>GetComponent&lt;Seeker&gt;();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>controller<sp/>=<sp/>GetComponent&lt;CharacterController&gt;();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Start<sp/>a<sp/>new<sp/>path<sp/>to<sp/>the<sp/>targetPosition,<sp/>return<sp/>the<sp/>result<sp/>to<sp/>the<sp/>OnPathComplete<sp/>function</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>seeker.<ref refid="class_seeker_1ad9c281f768379478a6a3671a53e09113" kindref="member" tooltip="Call this function to start calculating a path.">StartPath</ref><sp/>(transform.position,targetPosition,<sp/>OnPathComplete);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>OnPathComplete<sp/>(Path<sp/>p)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Debug.Log<sp/>(</highlight><highlight class="stringliteral">&quot;Yey,<sp/>we<sp/>got<sp/>a<sp/>path<sp/>back.<sp/>Did<sp/>it<sp/>have<sp/>an<sp/>error?<sp/>&quot;</highlight><highlight class="normal">+p.error);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!p.error)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>path<sp/>=<sp/>p;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Reset<sp/>the<sp/>waypoint<sp/>counter</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>currentWaypoint<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>FixedUpdate<sp/>()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(path<sp/>==<sp/>null)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//We<sp/>have<sp/>no<sp/>path<sp/>to<sp/>move<sp/>after<sp/>yet</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(currentWaypoint<sp/>&gt;=<sp/>path.vectorPath.Count)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Debug.Log<sp/>(</highlight><highlight class="stringliteral">&quot;End<sp/>Of<sp/>Path<sp/>Reached&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Direction<sp/>to<sp/>the<sp/>next<sp/>waypoint</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Vector3<sp/>dir<sp/>=<sp/>(path.vectorPath[currentWaypoint]-transform.position).normalized;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dir<sp/>*=<sp/>speed<sp/>*<sp/>Time.fixedDeltaTime;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>controller.SimpleMove<sp/>(dir);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Check<sp/>if<sp/>we<sp/>are<sp/>close<sp/>enough<sp/>to<sp/>the<sp/>next<sp/>waypoint</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//If<sp/>we<sp/>are,<sp/>proceed<sp/>to<sp/>follow<sp/>the<sp/>next<sp/>waypoint</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Vector3.Distance<sp/>(transform.position,path.vectorPath[currentWaypoint])<sp/>&lt;<sp/>nextWaypointDistance)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>currentWaypoint++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight></codeline>
</programlisting> If you press play now, the AI will follow the calculated path, neat, eh?<linebreak/>
 What the code does is to, in FixedUpdate get the normalized direction towards the next waypoint, move towards it a bit, then it checks if it is close enough to continue to the next waypoint, in this example that is done by simply by incrementing the currentWaypoint index.<linebreak/>
 The AI will stop a short distance from the end point, but that&apos;s just because we haven&apos;t got any special logic for the last point.<linebreak/>
</para></sect1>
<sect1 id="write-modifiers_1smoothing">
<title>Smoothing the Path</title>
<para>Now you have learned how to set up a simple grid graph and how to call the pathfinding, but surely there must be a way to get those paths to look a bit smoother?<linebreak/>
 Sure it is. Path smoothing and simplification scripts are called Path Modifiers and are scripts which can be added to the same GameObject as a <ref refid="class_seeker" kindref="compound">Seeker</ref>.<linebreak/>
 The most straight forward one is the Simple Smooth modifier which can be found at Components<ndash/>&gt;<ref refid="namespace_pathfinding" kindref="compound">Pathfinding</ref><ndash/>&gt;Modifiers<ndash/>&gt;Simple Smooth. Add that to our AI.<linebreak/>
</para><para>What this modifier is going to do, is to subdivide the path a number of times until each segment becomes smaller than the Max Segment Length variable. Then it will smooth the path by moving the points closer to each other. The modifier has a number of settings, I won&apos;t go through all of them here. See the <ref refid="class_simple_smooth_modifier" kindref="compound">SimpleSmoothModifier</ref> documentation for more info about each variable. For this tutorial you can set Max Segment Length to, say 1. Iterations to 5 and Strength to 0.25. Experiment with it to get good values.</para><para>Now press play again, the path should look much smoother, just as we wanted.<linebreak/>
 <simplesect kind="note"><para>Smoothers don&apos;t usually take world geometry or the graph into account, so be careful with applying too much smoothing since that could cause paths to pass through unwalkable areas.</para></simplesect>
<image type="html" name="getStarted_step4.png"></image>
</para><para>Another good modifier to use is the <ref refid="class_funnel_modifier" kindref="compound">FunnelModifier</ref> which will simplify the path a great deal. If you add it, make sure it has the top, or just below the StartEnd modifier, priority since it requires original path data to work. Read more about modifiers here <ref refid="modifiers" kindref="compound">Using Modifiers</ref> You can see a list of all modifiers if you click on Class Collections above and go to &quot;Modifiers&quot;.</para><para><linebreak/>
 </para></sect1>
<sect1 id="write-modifiers_1end">
<title>The End</title>
<para>That was the end of the Get Started tutorial. I hope you learned something from it.<linebreak/>
 From here on you can explore the rest of the documentation or dig straight in to the project.<linebreak/>
 If you want a litle better AI, you can use the <ref refid="class_a_i_path" kindref="compound">AIPath</ref> script which is included in the project. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
