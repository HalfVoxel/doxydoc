<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.3">
  <compounddef id="local-avoidance" kind="page">
    <compoundname>local-avoidance</compoundname>
    <title>Local Avoidance</title>
    <innerpage refid="writing-rvo-colliders">Writing RVO Colliders</innerpage>
    <detaileddescription>
<para>How to use the local avoidance in the A* <ref refid="namespace_pathfinding" kindref="compound">Pathfinding</ref> Project.</para><para>The local avoidance included in the A* <ref refid="namespace_pathfinding" kindref="compound">Pathfinding</ref> Project based on RVO - Reciprocal Velocity Obstacles and ORCA - Optimal Reciprocal Collision Avoidance. The implementation itself is largely based on the RVO2 Library but has been extended with many features to handle for example agents at different levels (agents at different floors in a building should not collide for example).</para><para><htmlonly> 
&lt;iframe width=&quot;640&quot; height=&quot;480&quot; src=&quot;http://www.youtube.com/embed/wxzrHRIiVyk&quot; frameborder=&quot;0&quot; allowfullscreen&gt;
&lt;/iframe&gt;
</htmlonly></para><para><variablelist>
<varlistentry><term><bold>A* Pro Feature:</bold></term></varlistentry>
<listitem><para>This is an A* Pathfinding Project Pro feature only. This function/class/variable might not exist in the Free version of the A* Pathfinding Project or the functionality might be limited<linebreak/>
The Pro version can be bought <ulink url="http://www.arongranberg.com/shop/a-pathfinding-project-pro/">here</ulink></para></listitem>
</variablelist>
</para><para>See also the subpages for more in-depth information:<itemizedlist>
<listitem><para><ref refid="writing-rvo-colliders_1writing-rvo-colliders" kindref="member">Writing RVO Colliders</ref></para></listitem></itemizedlist>
</para><sect1 id="local-avoidance_1numbercrunching">
<title>Number Crunching</title>
<para>So how fast is this system then, you might wonder. It is very high performance. Especially if you take into account the fact that a local avoidance simulation does not need to run at a very high fps, that&apos;s just a waste of CPU cycles. I have been able to simulate 5000 agents at a relatively good fps on my laptop. The local avoidance simulation ran at about 10 fps and the game ran at 25-35 fps mostly, with a lowest fps of around 15. The visualization for this simulation was done simply by creating a mesh which held one square for each agent. The reason for this is that at such high numbers, creating a GameObject for every agent is really slow, just creating that many agents took something like 10 seconds I think. The agents were setup in a circle and trying to reach their antipodal points. So it was basically as crowded as it can get.</para><para>On my other computer with a bit more power (i7 processor) I can simulate 10000 agents with game running at about 60 fps and rvo simulation running at 30 fps.</para><para>However do not count on having this high number of agents in your game. These examples were very lightweight and in a game there is usually lots of overhead from many other things.</para></sect1>
<sect1 id="local-avoidance_1overview">
<title>Overview</title>
<para>For this reason, that Unity can be a limiting factor, the system is divided into two parts. First there is the core simulation code. It is completely independent of Unity specific objects such as GameObjects and MonoBehaviours. The only really Unity specific classes it uses is the Vector3 and Vector2 structs which are easily interchangeable. This core handles all simulation of rvo (local avoidance) agents.</para><para>The second part is the Unity interface. Many of those classes are just wrappers for the corresponding core classes. The <ref refid="class_r_v_o_simulator" kindref="compound">RVOSimulator</ref> class is for example just a wrapper class for the <ref refid="class_pathfinding_1_1_r_v_o_1_1_simulator" kindref="compound">Pathfinding.RVO.Simulator</ref> class. The Unity interface also contains helper classes for much easier local avoidance integration. One of those is the <ref refid="class_r_v_o_controller" kindref="compound">RVOController</ref> which you will probably use quite a lot. It is written to be an almost drop-in replacement for the Unity Character Controller, supporting functions such as Move and has properties such as velocity which you can easily access.</para><para>All of the scripts in the Unity interface part share common assumptions on how the scene should be set up: There should always be one <ref refid="class_r_v_o_simulator" kindref="compound">RVOSimulator</ref> in the scene, other scripts will look for it and get the core simulator instance it is a wrapper for. You can simply add it to any GameObject, edit the few settings if you want and it will work. Preferably you should have no more than one, all scripts which look for it use FindObjectOfType and there is no easy way to control exactly which of the multiple RVOSimulators it will return, so keep it to one for simplicity&apos;s sake.</para></sect1>
<sect1 id="local-avoidance_1integration">
<title>Integration</title>
<para>Ok, you now know sort of how it is structured, let&apos;s build a small concrete example so you can see how it works.<linebreak/>
 Start by creating a new scene, add a large plane as a ground (position (0,0,0), scale (10,10,10)). Then add a new GameObject, name it &quot;Simulator&quot;. Now add the component <ref refid="class_r_v_o_simulator" kindref="compound">RVOSimulator</ref>, you can find it in Components -&gt; Local Avoidance -&gt; RVO Simulator. You can see that it has a few options, but you can leave them at the default setting for now. However I recommend that you read the class documentation for the <ref refid="class_r_v_o_simulator" kindref="compound">RVOSimulator</ref> later since the performance is very dependent on those few settings. This component will handle the simulation of our agents as well as storing any dynamic obstacles we add (more about those later).</para><para>Now we want an AI to walk around. It will be a very simple AI, it will basically walk forward. So first add a new Cylinder to the scene (GameObject -&gt; Create Other -&gt; Cylinder). It will create a cylinder with a height of 2 units somewhere in the scene, place it somewhere visible above the ground plane we added before. Add to this GameObject the component <ref refid="class_r_v_o_controller" kindref="compound">RVOController</ref>, you can find it at Components -&gt; Local Avoidance -&gt; RVO Controller. This component is designed to be an almost drop-in replacement for the Unity Character Controller, so if you have used the character controller, you will feel at home with this one. It does not, for obvious reasons support some collision specific things, like collision flags but it is very similar. Since our cylinder is 2 units high, set the height variable on the <ref refid="class_r_v_o_controller" kindref="compound">RVOController</ref> to 2.</para><para>Now press play! If everything goes well there is a very high probability that your cylinder goes flying into the air. That is expected and I will tell you how to avoid it. If you are not seeing this behavior from your cylinder it is the floating point math which has a nice day. Move the cylinder around a bit and you will probably see it.</para><para>So what is causing this? To be able to position the agent at the correct Y coordinate, and since colliders are not used, the <ref refid="class_r_v_o_controller" kindref="compound">RVOController</ref> uses raycasting. Basically it fires a ray from the center of the agent downwards and see where it hits, then it places the agent&apos;s feet at that point. The problem here is that the cylinder has a capsule collider attached, so the ray will hit the capsule and the script will position the agent a tiny distance upwards from it&apos;s previous position. The next frame, it will again find the capsule collider and position it a bit further up, and so it continues and creates the effect of the cylinder flying into the air. The solution is simple, either you remove the capsule collider from the agent which is the most straight forward thing to do since it will not be needed anymore, or if you really want to keep it, you can place the agent in another layer and edit the &quot;mask&quot; variable on the <ref refid="class_r_v_o_controller" kindref="compound">RVOController</ref> component. I will not go through all the settings of the <ref refid="class_r_v_o_controller" kindref="compound">RVOController</ref> component here, take a look at the class documentation for reference.</para><para>Now that we have our AI standing on the ground, we want to tell it to do something: so fire up your favorite text editor and create a script called SimpleRVOAI.cs. Here is what it should contain: <programlisting><codeline><highlight class="keyword">using</highlight><highlight class="normal"><sp/>UnityEngine;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>System.Collections;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">SimpleRVOAI<sp/>:<sp/>MonoBehaviour<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="class_r_v_o_controller" kindref="compound" tooltip="RVO Character Controller.">RVOController</ref><sp/>controller;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Use<sp/>this<sp/>for<sp/>initialization</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Start<sp/>()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>controller<sp/>=<sp/>GetComponent&lt;RVOController&gt;();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Update<sp/>is<sp/>called<sp/>once<sp/>per<sp/>frame</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Update<sp/>()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>controller.Move<sp/>(transform.forward<sp/>*<sp/>10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> It does&apos;t take an expert coder to see what that does. We simply get the <ref refid="class_r_v_o_controller" kindref="compound">RVOController</ref> at start and every frame we set the desired velocity to 10 meters per second in the forward direction, as simple as that. If you add this script to your cylinder and press play, it should move forward in a steady phase.</para><para>Now for the fun part. Duplicate the cylinder and place it some distance in front of the first one, then rotate it so that they are facing each other. Press play. The cylinders should move towards each other, and just before collision, avoid each other! Ain&apos;t that awesome!</para><para>The included AI script (<ref refid="class_a_i_path" kindref="compound">AIPath</ref>) support the <ref refid="class_r_v_o_controller" kindref="compound">RVOController</ref> out of the box, simply add the <ref refid="class_r_v_o_controller" kindref="compound">RVOController</ref> to a GameObject with an <ref refid="class_a_i_path" kindref="compound">AIPath</ref> component and make sure it has no other movement components (rigidbody or charactercontroller) and it will detect the <ref refid="class_r_v_o_controller" kindref="compound">RVOController</ref>.</para></sect1>
<sect1 id="local-avoidance_1obstacles">
<title>Obstacles</title>
<para>Obstacles, dynamic and static can be added to the simulation. This first part will discuss navmeshes and the second part will discuss obstacles more generally.</para><sect2 id="local-avoidance_1rvo-navmeshes">
<title>Navmeshes</title>
<para>If you are using a navmesh based graph, it is very likely that you want your agents to not go outside, and perhaps even avoid the border of the graph. Fortunately for you, there is a simple script written just to do just that. It is called <ref refid="class_r_v_o_navmesh" kindref="compound">RVONavmesh</ref> and can be found at Components -&gt; Local Avoidance -&gt; RVO Navmesh. Add that to any GameObject in your scene and it will, when a graph is scanned or loaded add it&apos;s border as an RVO obstacle.</para><para><simplesect kind="note"><para>Support for grid graphs will be included in a future update, right now only navmesh based graphs have support</para></simplesect>
</para></sect2>
<sect2 id="local-avoidance_1obstacles">
<title>Obstacles</title>
<para>Obstacles can be added to the simulation. The agents will not be able to pass through them (unless moving at very high speed relative to fps) and agents can also avoid them by both basic local avoidance but the <ref refid="class_r_v_o_controller" kindref="compound">RVOController</ref> can also apply force based avoidance from walls since it often looks better when AIs are not hugging the walls so to speak.</para><para>A few built-in colliders can be found in Components -&gt; Local Avoidance. If you want to write custom colliders, take a look at the page for doing so (<ref refid="writing-rvo-colliders_1writing-rvo-colliders" kindref="member">Writing RVO Colliders</ref>).</para><para>The build-in colliders can be moved around however you want and they will be updated appropriately. But just because they can be moved around it doesn&apos;t mean they can be used to push agents around. In fact, they are quite bad at it. As long as they move very slowly, it works, but if they move too fast, the agents can get stuck inside.</para><para>The one variable the colliders have in common is the Obstacle Mode field. The internal workings for it is explained in the <ref refid="writing-rvo-colliders_1writing-rvo-colliders" kindref="member">Writing RVO Colliders</ref> tutorial, but it is pretty basic. KeepOut will block agents from moving into the obstacle, but not from moving out from it when they are inside, KeepIn will do the opposite, and Both will prevent them from crossing the border either direction. </para></sect2>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
