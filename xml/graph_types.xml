<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.3">
  <compounddef id="graph_types" kind="page">
    <compoundname>graphTypes</compoundname>
    <title>Graph Types</title>
    <detaileddescription>
<para>There are several different graph types included in the project, and there is the availability to create your own.</para><para><linebreak/>
 In this document I will shortly explain the different graph types and their settings.<linebreak/>
 <linebreak/>
 </para><sect1 id="graph_types_1grid">
<title>Grid Graph</title>
<para>The Grid Graph is the most straight forward graph. It generates nodes in a grid pattern width*depth.<linebreak/>
 It works great for most scenes and is especially good when runtime changing of the graph is needed (such as in an RTS or Tower Defence game).<linebreak/>
 <htmlonly> &lt;div class=&quot;tinyshadow&quot;&gt;&lt;img src=&quot;images/gridgraph_graph.png&quot;/&gt;&lt;/div&gt;</htmlonly></para><para><simplesect kind="see"><para><ref refid="class_pathfinding_1_1_grid_graph" kindref="compound">Pathfinding.GridGraph</ref></para></simplesect>
</para></sect1>
<sect1 id="graph_types_1navmesh">
<title>Navmesh Graph</title>
<para>The Navmesh Graph is the other main graph type. This graph expresses the pathfinding data as a triangle mesh instead of squares (<ref refid="graph_types_1grid" kindref="member">Grid Graph</ref>) or point (<ref refid="graph_types_1point" kindref="member">Point Graph</ref>).<linebreak/>
 This is perfect for smooth and fast pathfinding where the graph doesn&apos;t need much changing during runtime.<linebreak/>
 It is often faster than a grid graph since it usually contains fewer nodes and thus requires less searching.<linebreak/>
 The paths returned from it can be used directly, but the funnel modifier is strongly recommended.<linebreak/>
 <linebreak/>
 The system can generate navmeshes automatically (see <ref refid="graph_types_1recast" kindref="member">Recast Graph - A* Pro Only</ref>), but with this graph you will have to create them yourself in your favourite 3D modelling application.<linebreak/>
 A navmesh should be a mesh where the polygons describe the walkable area, vertices should always (except possibly in some special cases) lie at the edges of the mesh, not in the middle of it (i.e a vertex with polygons surrounding it).<linebreak/>
 It can also be good to split very long edges because similarly sized polygons yield better paths than really big and really small polygons next to each other.<linebreak/>
 <htmlonly> &lt;div class=&quot;tinyshadow&quot;&gt;&lt;img src=&quot;images/navmeshgraph_graph.png&quot;/&gt;&lt;/div&gt;</htmlonly></para><para><simplesect kind="see"><para><ref refid="class_pathfinding_1_1_nav_mesh_graph" kindref="compound">Pathfinding.NavMeshGraph</ref></para></simplesect>
</para></sect1>
<sect1 id="graph_types_1point">
<title>Point Graph</title>
<para>The PointGraph is the simplest of all graph types, but allows for a lot of customization, it consists of a bunch of user placed points which are linked together. A point graph is scanned by taking a root Transform, and treating every child of it as a node. It then checks the connections between the nodes using raycasts to see if they should be linked together.<linebreak/>
 To get good, smooth paths from a point graph might be hard as they only define a point of walkability, not an area like the two previous graph types. The raycast modifier does a quite good job though.<linebreak/>
 A problem is that when getting the closest nodes for a path request, the closest node might be a node on the other side of a wall, so make sure you don&apos;t place your nodes too sparse.<linebreak/>
 <htmlonly> &lt;div class=&quot;tinyshadow&quot;&gt;&lt;img src=&quot;images/pointGraph.png&quot;/&gt;&lt;/div&gt;</htmlonly> <simplesect kind="see"><para><ref refid="class_pathfinding_1_1_point_graph" kindref="compound">Pathfinding.PointGraph</ref></para></simplesect>
</para></sect1>
<sect1 id="graph_types_1recast">
<title>Recast Graph - A* Pro Only</title>
<para>The Recast Graph type is by far the most advanced graph generator in this system. It is based on <ulink url="http://code.google.com/p/recastnavigation/">Recast</ulink>, an open source navmesh and navigation system in C++ which I have translated a part of to C# to run it natively in Unity.<linebreak/>
 The recast graph generator will voxelize the world (sort of rasterize it to a lot of cubes) and then build a navigation mesh of it which can be used similar to the <ref refid="graph_types_1navmesh" kindref="member">Navmesh Graph</ref>.<linebreak/>
 It can generate a stable mesh in seconds what could take hours using manual mesh building. <htmlonly> &lt;div class=&quot;tinyshadow&quot;&gt;&lt;img src=&quot;images/recastGraph.png&quot;/&gt;&lt;/div&gt;</htmlonly> <simplesect kind="see"><para><ref refid="class_pathfinding_1_1_recast_graph" kindref="compound">Pathfinding.RecastGraph</ref></para></simplesect>
</para></sect1>
<sect1 id="graph_types_1layergrid">
<title>Layered Grid Graph - A* Pro Only</title>
<para>The GridGraph is great, but sometimes the world contains overlapping areas, such as a house with multiple floors. The GridGraph cannot handle that in a good way. So here&apos;s a grid graph which supports overlapping areas. It is a bit limited in some aspects, it does not support graph updating using GraphUpdateObjects (yet, working on it) and uses a bit more memory than a grid graph. But it works great when you need a grid graph for overlapping areas. <htmlonly> &lt;div class=&quot;tinyshadow&quot;&gt;&lt;img src=&quot;images/layergridgraph_graph.png&quot;/&gt;&lt;/div&gt;</htmlonly> <simplesect kind="see"><para>Pathfinding.LayerGridGraph </para></simplesect>
</para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
