<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.3">
  <compounddef id="graph-updates" kind="page">
    <compoundname>graph-updates</compoundname>
    <title>Graph Updates during Runtime</title>
    <detaileddescription>
<sect1 id="graph-updates_1Overview">
<title>Overview</title>
<para>Many graphs supports updating during runtime without a complete rescan. Best implemented is the GridGraph and PointGraph, but navmesh based ones also has support for it.<linebreak/>
 Graph Updates can either be done using the <ref refid="class_graph_update_scene" kindref="compound">GraphUpdateScene</ref> component which does all the heavy work for you or using scripting which is done by calling a central function in the <ref refid="class_astar_path" kindref="compound">AstarPath</ref> class with either a Bounds object or a <ref refid="class_pathfinding_1_1_graph_update_object" kindref="compound">Pathfinding::GraphUpdateObject</ref> (which is what the <ref refid="class_graph_update_scene" kindref="compound">GraphUpdateScene</ref> component actually does in the background). <programlisting><codeline><highlight class="normal"><sp/><ref refid="class_astar_path" kindref="compound" tooltip="Main Pathfinding System.">AstarPath</ref>.<ref refid="class_astar_path_1afd00b3509dcd7d1a4ac45bcef6c7e200" kindref="member" tooltip="Returns the active AstarPath object in the scene.">active</ref>.<ref refid="class_astar_path_1ab418dfc993a7451f87bd9c7f9a5b5ef5" kindref="member" tooltip="Update all graphs within bounds after t seconds.">UpdateGraphs</ref><sp/>(myBounds);</highlight></codeline>
<codeline><highlight class="normal"><ref refid="class_astar_path" kindref="compound" tooltip="Main Pathfinding System.">AstarPath</ref>.<ref refid="class_astar_path_1afd00b3509dcd7d1a4ac45bcef6c7e200" kindref="member" tooltip="Returns the active AstarPath object in the scene.">active</ref>.<ref refid="class_astar_path_1ab418dfc993a7451f87bd9c7f9a5b5ef5" kindref="member" tooltip="Update all graphs within bounds after t seconds.">UpdateGraphs</ref><sp/>(myGraphUpdateObject);</highlight></codeline>
</programlisting> The function will then put the task in a queue to be carried out before the next path calculation. It has to be put in a queue because if it carried out directly, it might interfere with pathfinding, especially if multithreading is on, and cause all kinds of errors. This means that you might not see an update of the graph directly, but it will always be updated before the next pathfinding calculation starts (almost always, see <ref refid="class_astar_path_1aae2403939ee3da2029ad5e80042dc8c3" kindref="member">AstarPath.limitGraphUpdates</ref> ).<linebreak/>
</para></sect1>
<sect1 id="graph-updates_1editor">
<title>Using the GraphUpdateScene component</title>
<para>The <ref refid="class_graph_update_scene" kindref="compound">GraphUpdateScene</ref> component is really easy to use. Create a new empty GameObject and add the component to it, it can be found in Components<ndash/>&gt;<ref refid="namespace_pathfinding" kindref="compound">Pathfinding</ref><ndash/>&gt;<ref refid="class_graph_update_scene" kindref="compound">GraphUpdateScene</ref>.<linebreak/>
 When you have added the component, you should see something like the image below. <htmlonly> &lt;div class=&quot;tinyshadow&quot;&gt;&lt;img src=&quot;images/graphUpdateScene.png&quot;/&gt;&lt;/div&gt;</htmlonly> The area which the component will affect is defined by creating a polygon in the scene. If you make sure you have the Position tool enabled (top-left corner of the Unity window) you can shift-click in the scene view to add more points to the polygon. You can remove points using shift-alt-click. By clicking on the points you can bring up a positioning tool. You can also open the &quot;points&quot; array in the inspector to set each point&apos;s coordinates. <htmlonly> &lt;div class=&quot;tinyshadow&quot;&gt;&lt;img src=&quot;images/graphUpdateScenePoly.png&quot;/&gt;&lt;/div&gt;</htmlonly> In the inspector there are a number of variables. The first one is named &quot;Convex&quot;, it sets if the convex hull of the points should be calculated or if the polygon should be used as-is. Using the convex hull is faster when applying the changes to the graph, but with a non-convex polygon you can specify more complicated areas.<linebreak/>
 The next two variables, called &quot;Apply On Start&quot; and &quot;Apply On Scan&quot; determine when to apply the changes. If the object is in the scene from the beginning, both can be left on, it doesn&apos;t matter since the graph is also scanned at start. However if you instantiate it later in the game, you can make it apply it&apos;s setting directly, or wait until the next scan (if any). If the graph is rescanned, all <ref refid="class_graph_update_scene" kindref="compound">GraphUpdateScene</ref> components which have the Apply On Scan variable toggled will apply their settings again to the graph since rescanning clears all previous changes.<linebreak/>
 You can also make it apply it&apos;s changes using scripting. <programlisting><codeline><highlight class="normal">GetComponent&lt;GraphUpdateScene&gt;().Apply<sp/>();<sp/></highlight></codeline>
</programlisting> The above code will make it apply it&apos;s changes to the graph (assuming a <ref refid="class_graph_update_scene" kindref="compound">GraphUpdateScene</ref> component is attached to the same GameObject).</para><para>Next there is &quot;Modify Walkability&quot; and &quot;Set Walkability&quot; (which appears when &quot;Modify Walkability&quot; is toggled). If Modify Walkability is set, then all nodes inside the area will either be set to walkable or unwalkable depending on the value of the &quot;Set Walkability&quot; variable.</para><para>Penalty can also be applied to the nodes. A higher penalty (aka weight) makes the nodes harder to traverse so it will try to avoid those areas.</para><para>The tagging variables can be read more about on this page: <ref refid="tags" kindref="compound">Working with tags</ref>.</para></sect1>
<sect1 id="graph-updates_1scripting">
<title>Using Scripting</title>
<para>When updating is carried out, all graphs will be looped over and those which can be updated (all built in ones) will have their UpdateArea function called (i.e be updated).<linebreak/>
 Each node is updated by the graphs calling <ref refid="class_pathfinding_1_1_graph_update_object_1a07c9193c307065c2a9f21d428f140e23" kindref="member">Pathfinding::GraphUpdateObject::Apply</ref> sending each affected node to it, the Apply function will then change penalty, walkability or other parameters specified. Graphs can also use custom updating logic, such as the GridGraph (see <ref refid="graph-updates_1gridgraphs" kindref="member">Updating GridGraphs</ref>). You do not have to understand all different function calls to be able to use it, those are mostly for people who want to mess around with the source code.</para><sect2 id="graph-updates_1penalty">
<title>Changing penalty</title>
<para>A common task is to add a penalty (weight) to some nodes to make it be avoided by the algorithm, in other words make the area slower/harder to traverse. This can be done relatively easy using GraphUpdateObjects. <programlisting><codeline><highlight class="normal"><sp/></highlight><highlight class="comment">//using<sp/>Pathfinding;<sp/>//At<sp/>top<sp/>of<sp/>script</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">GraphUpdateObject<sp/>guo<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>GraphUpdateObject(myBounds);</highlight></codeline>
<codeline><highlight class="normal">guo.addPenalty<sp/>=<sp/>10000;<sp/></highlight><highlight class="comment">//Here<sp/>goes<sp/>the<sp/>penalty<sp/>to<sp/>apply,<sp/>you<sp/>need<sp/>quite<sp/>large<sp/>values<sp/>usually</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="class_astar_path" kindref="compound" tooltip="Main Pathfinding System.">AstarPath</ref>.<ref refid="class_astar_path_1afd00b3509dcd7d1a4ac45bcef6c7e200" kindref="member" tooltip="Returns the active AstarPath object in the scene.">active</ref>.<ref refid="class_astar_path_1ab418dfc993a7451f87bd9c7f9a5b5ef5" kindref="member" tooltip="Update all graphs within bounds after t seconds.">UpdateGraphs</ref><sp/>(guo);</highlight></codeline>
</programlisting> The myBounds variable referred to is a UnityEngine.Bounds object. It defines an axis aligned box in which to update the graphs in.</para><para>If you don&apos;t need to update walkability when using a grid graph or connections when using a point graph, you can set updatePhysics (see <ref refid="graph-updates_1gridgraphs" kindref="member">Updating GridGraphs</ref>) to false to avoid unnecessary calculations <programlisting><codeline><highlight class="normal">guo.updatePhysics<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;<sp/></highlight></codeline>
</programlisting></para></sect2>
<sect2 id="graph-updates_1gridgraphs">
<title>Updating GridGraphs</title>
<para>The GraphUpdateObject::updatePhysics variable matters a lot when updating grid graphs. If it is set to true, all nodes affected will have their height recalculated and then checked if they are still walkable. You usually want to leave this to true when updating a grid graph.</para><para>A common misstake is to create a new obstacle in the scene, and do something like this: <programlisting><codeline><highlight class="normal">GameObject<sp/>obstacle<sp/>=<sp/>GameObject.Instantiate<sp/>(obstaclePrefab,somePosition,Quaternion.identity)<sp/>as<sp/>GameObject;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="class_astar_path" kindref="compound" tooltip="Main Pathfinding System.">AstarPath</ref>.<ref refid="class_astar_path_1afd00b3509dcd7d1a4ac45bcef6c7e200" kindref="member" tooltip="Returns the active AstarPath object in the scene.">active</ref>.<ref refid="class_astar_path_1ab418dfc993a7451f87bd9c7f9a5b5ef5" kindref="member" tooltip="Update all graphs within bounds after t seconds.">UpdateGraphs</ref><sp/>(obstacle.collider.bounds);</highlight></codeline>
</programlisting> And expect the area under the obstacle to become unwalkable. The misstake is often that one does not check that the obstacle is in a layer which would make the nodes unwalkable in the first place. The GridGraph&apos;s settings for collision checking has a mask field, one must make sure the obstacle is in a layer contained in that mask.</para><sect3 id="graph-updates_1grigraphinternal">
<title>Internal Workings</title>
<para>When updating a GridGraph, the GraphUpdateObject&apos;s Apply function will be called for each node inside the bounds, it will check the GraphUpdateObject::updatePhysics variable, if it is true (which is the default value), the area will be expanded by the diameter of the Collision Testing and every node inside the area will be checked for collisions. If it is false, however, only the Apply function will be called for the nodes inside the area (not expanded) and nothing else will be done.<linebreak/>
</para></sect3>
</sect2>
<sect2 id="graph-updates_1navmeshes">
<title>Updating Navmesh based Graphs</title>
<para>Navmesh based graphs (NavMeshGraph and RecastGraph) only have support for updating penalty, walkability and similar on already existing nodes. New nodes cannot be created using GraphUpdateObjects. The GraphUpdateObject will affect all nodes/triangles which intersect or are contained by the GUO&apos;s bounds.<linebreak/>
</para></sect2>
<sect2 id="graph-updates_1pointgraphs">
<title>Updating Point Graphs</title>
<para>Point graphs will call Apply on every node inside the bounds and also, if GraphUpdateObject::updatePhysics is set to true (default true), it will recalculate any connections which passes through the bounds object.</para></sect2>
<sect2 id="graph-updates_1graphupdateobject">
<title>The Graph Update Object</title>
<para>The GraphUpdateObject contains some basic variables on how to update each node. See documentation for the <ref refid="class_pathfinding_1_1_graph_update_object" kindref="compound">Pathfinding::GraphUpdateObject</ref> for more info.</para><sect3 id="graph-updates_1inheriting">
<title>Inheriting from the GraphUpdateObject</title>
<para>Classes can inherit from the GraphUpdateObject to override some functionality.<linebreak/>
 Here&apos;s an example of a GraphUpdateObject which moves nodes by some offset while still keeping the base functionality. <programlisting><codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>Pathfinding;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">MyGUO<sp/>:<sp/>GraphUpdateObject<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Vector3<sp/>offset<sp/>=<sp/>Vector3.up;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal"><sp/>Apply<sp/>(Node<sp/>node)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Keep<sp/>the<sp/>base<sp/>functionality</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>base.Apply<sp/>(node);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//The<sp/>position<sp/>of<sp/>a<sp/>node<sp/>is<sp/>an<sp/>Int3,<sp/>so<sp/>we<sp/>need<sp/>to<sp/>cast<sp/>the<sp/>offset</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node.position<sp/>+=<sp/>(Int3)offset;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> You could then use that GUO like this:</para><para><programlisting><codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Start<sp/>()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>MyGUO<sp/>guo<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>MyGUO<sp/>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>guo.offset<sp/>=<sp/>Vector3.up*2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>guo.bounds<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>Bounds<sp/>(Vector3.zero,Vector3.one*10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="class_astar_path" kindref="compound" tooltip="Main Pathfinding System.">AstarPath</ref>.<ref refid="class_astar_path_1afd00b3509dcd7d1a4ac45bcef6c7e200" kindref="member" tooltip="Returns the active AstarPath object in the scene.">active</ref>.<ref refid="class_astar_path_1ab418dfc993a7451f87bd9c7f9a5b5ef5" kindref="member" tooltip="Update all graphs within bounds after t seconds.">UpdateGraphs</ref><sp/>(guo);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para></sect3>
</sect2>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
